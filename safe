Running nmap full port scan : nmap -p- --min-rate 10000 10.10.10.147
PORT      STATE    SERVICE
22/tcp    open     ssh
80/tcp    open     http
101/tcp   filtered hostname
1319/tcp  filtered amx-icsp
1337/tcp  open     waste
7393/tcp  filtered nfoldman
11351/tcp filtered unknown
14276/tcp filtered unknown
14713/tcp filtered unknown
17281/tcp filtered unknown
17859/tcp filtered unknown
17950/tcp filtered unknown
32326/tcp filtered unknown
32348/tcp filtered unknown
35540/tcp filtered unknown
45867/tcp filtered unknown
46462/tcp filtered unknown
50279/tcp filtered unknown
57226/tcp filtered unknown
57466/tcp filtered unknown
We visit the site and find it's a default apache installation. Checking the source code we see the below comment :
<!-- 'myapp' can be downloaded to analyze from here
     its running on port 1337 -->
On visiting the site on port 1337, we note the below response:
 12:22:01 up 13:49,  0 users,  load average: 0.00, 0.00, 0.00

What do you want me to echo back? GET /myapp HTTP/1.1
Searching a bit on Google, we realize this is an indicator to ROP buffer overflow.
We download the myapp as : wget http://10.10.10.147/myapp, check the file using strings and realize it might be C based application. Many functions in the app
suggests so. Running a file against it gives : "myapp: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked"

We make the app executable "chmod +x myapp" and run it ./myapp and we note it just echoes back what we send it.
What do you want me to echo back? echo
echo
We use python to generate a couple of A's and send it to the program to see if it crushes: "print("A"*150)"
A hundred and fifty A's crashes the app:
What do you want me to echo back? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault

We open this binary with gdb for further analysis : "gdb myapp". 
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
r2 ./myapp
[0x00401070]> aaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for vtables
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
[0x00401070]> afl
0x00401070    1 42           entry0
0x004010b0    4 33   -> 31   sym.deregister_tm_clones
0x004010e0    4 49           sym.register_tm_clones
0x00401120    3 33   -> 28   sym.__do_global_dtors_aux
0x00401150    1 2            entry.init0
0x00401210    1 1            sym.__libc_csu_fini
0x00401214    1 9            sym._fini
0x004011b0    4 93           sym.__libc_csu_init
0x004010a0    1 1            sym._dl_relocate_static_pie
0x0040115f    1 78           main
0x00401040    1 6            sym.imp.system
0x00401050    1 6            sym.imp.printf
0x00401060    1 6            sym.imp.gets
0x00401030    1 6            sym.imp.puts
0x00401000    3 23           sym._init
0x00401152    1 10           sym.test

References:
1. https://bufferoverflows.net/getting-started-with-linux-buffer-overflow/
2. https://bufferoverflows.net/for-beginners-linux-buffer-overflow-challenge/
3. https://bufferoverflows.net/ret2libc-exploitation-example/
4. https://bufferoverflows.net/camp-ctf-2015-bitterman-write-up/
